const { SUPABASE_URL, SUPABASE_ANON_KEY, SCENARIO_ID } = window.APP_CONFIG;
const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

let chartFundsPie = null;
let chartPeoplePie = null;
let chartTime = null;
let chartMoney = null;

let cache = null;

document.addEventListener("DOMContentLoaded", async () => {
  document.getElementById("scenarioIdPill").innerText = SCENARIO_ID;
  await loadDashboard();
  document.getElementById("exportCsv").onclick = exportAggregatedCsv;
});

async function loadDashboard() {
  // Always-visible context first
  const [budgetsRes, peopleRes, tasksRes, playsRes] = await Promise.all([
    db.from("budget_lines").select("*").eq("scenario_id", SCENARIO_ID),
    db.from("people").select("*").eq("scenario_id", SCENARIO_ID),
    db.from("tasks").select("*").eq("scenario_id", SCENARIO_ID),
    db.from("playthroughs").select("*").eq("scenario_id", SCENARIO_ID).order("submitted_at", { ascending: false })
  ]);

  const budgets = budgetsRes.data || [];
  const people = peopleRes.data || [];
  const tasks = tasksRes.data || [];
  const plays = playsRes.data || [];

  renderFundsPie(budgets);
  renderPeoplePie(people);

  // If no submissions yet, still render empty charts + placeholders
  if (!plays.length) {
    renderCharts(tasks, new Map(), new Map());
    renderIgnoredTasks(tasks, new Map(), new Map());
    renderSubmissions([], []);
    cache = { tasks, budgets, people, plays: [], timeByTask: new Map(), moneyByTask: new Map() };
    return;
  }

  const playIds = plays.map(p => p.id);

  const [timeRes, moneyRes, logsRes] = await Promise.all([
    db.from("time_allocations").select("*").in("playthrough_id", playIds),
    db.from("budget_allocations").select("*").in("playthrough_id", playIds),
    db.from("logs").select("*").in("playthrough_id", playIds)
  ]);

  const time = timeRes.data || [];
  const money = moneyRes.data || [];
  const logs = logsRes.data || [];

  // Aggregate per task
  const timeByTask = new Map();   // task_id -> total pct
  const moneyByTask = new Map();  // task_id -> total nok (handlingsrom only in practice, but allocations are only from game anyway)

  time.forEach(a => {
    const k = a.task_id;
    timeByTask.set(k, (timeByTask.get(k) || 0) + Number(a.pct || 0));
  });

  money.forEach(a => {
    const k = a.task_id;
    // schema uses amount_nok; earlier versions used amount. Handle both.
    const amt = Number(a.amount_nok ?? a.amount ?? 0);
    moneyByTask.set(k, (moneyByTask.get(k) || 0) + amt);
  });

  renderCharts(tasks, timeByTask, moneyByTask);
  renderIgnoredTasks(tasks, timeByTask, moneyByTask);
  renderSubmissions(plays, logs);

  cache = { tasks, budgets, people, plays, timeByTask, moneyByTask };
}

function renderFundsPie(budgets) {
  const statSum = budgets
    .filter(b => (b.type || "").toLowerCase() === "stat")
    .reduce((s, b) => s + Number(b.amount_nok || 0), 0);

  const flexSum = budgets
    .filter(b => (b.type || "").toLowerCase() === "handlingsrom")
    .reduce((s, b) => s + Number(b.amount_nok || 0), 0);

  const total = statSum + flexSum;

  document.getElementById("fundsText").innerText =
    `Totalt: ${total.toLocaleString("nb-NO")} kr — ` +
    `Låst (stat): ${statSum.toLocaleString("nb-NO")} kr, ` +
    `Handlingsrom: ${flexSum.toLocaleString("nb-NO")} kr`;

  const ctx = document.getElementById("chartFundsPie").getContext("2d");
  if (chartFundsPie) chartFundsPie.destroy();

  chartFundsPie = new Chart(ctx, {
    type: "doughnut",
    data: {
      labels: ["Låst (statlige midler)", "Fleksibelt (handlingsrom)"],
      datasets: [{ data: [statSum, flexSum] }]
    },
    options: {
      plugins: {
        legend: { position: "bottom" },
        tooltip: {
          callbacks: {
            label: (item) => `${item.label}: ${Number(item.raw).toLocaleString("nb-NO")} kr`
          }
        }
      }
    }
  });
}

function renderPeoplePie(people) {
  const sorted = [...people].sort((a, b) => Number(b.capacity_pct || 0) - Number(a.capacity_pct || 0));
  const labels = sorted.map(p => p.name);
  const values = sorted.map(p => Number(p.capacity_pct || 0));

  const total = values.reduce((s, v) => s + v, 0);
  document.getElementById("peopleText").innerText =
    `Total registrert kapasitet: ${total}% (sum av capacity_pct).`;

  const ctx = document.getElementById("chartPeoplePie").getContext("2d");
  if (chartPeoplePie) chartPeoplePie.destroy();

  chartPeoplePie = new Chart(ctx, {
    type: "doughnut",
    data: {
      labels,
      datasets: [{ data: values }]
    },
    options: {
      plugins: {
        legend: { position: "bottom" },
        tooltip: {
          callbacks: {
            label: (item) => `${item.label}: ${item.raw}%`
          }
        }
      }
    }
  });
}

function renderCharts(tasks, timeByTask, moneyByTask) {
  const topTime = tasks
    .map(t => ({ title: t.title, val: timeByTask.get(t.id) || 0 }))
    .sort((a, b) => b.val - a.val)
    .slice(0, 12);

  const topMoney = tasks
    .map(t => ({ title: t.title, val: moneyByTask.get(t.id) || 0 }))
    .sort((a, b) => b.val - a.val)
    .slice(0, 12);

  // Time
  if (chartTime) chartTime.destroy();
  chartTime = new Chart(document.getElementById("chartTime").getContext("2d"), {
    type: "bar",
    data: {
      labels: topTime.map(x => x.title),
      datasets: [{ label: "Total tid (%)", data: topTime.map(x => x.val) }]
    },
    options: {
      plugins: { legend: { display: false } },
      scales: { y: { beginAtZero: true } }
    }
  });

  // Money
  if (chartMoney) chartMoney.destroy();
  chartMoney = new Chart(document.getElementById("chartMoney").getContext("2d"), {
    type: "bar",
    data: {
      labels: topMoney.map(x => x.title),
      datasets: [{ label: "Total handlingsrom (NOK)", data: topMoney.map(x => x.val) }]
    },
    options: {
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: (item) => `${Number(item.raw).toLocaleString("nb-NO")} kr`
          }
        }
      },
      scales: { y: { beginAtZero: true } }
    }
  });
}

function renderIgnoredTasks(tasks, timeByTask, moneyByTask) {
  const ignored = tasks.filter(t => {
    const tVal = timeByTask.get(t.id) || 0;
    const mVal = moneyByTask.get(t.id) || 0;
    return tVal === 0 && mVal === 0;
  });

  const wrap = document.getElementById("ignoredTasks");
  if (!ignored.length) {
    wrap.innerHTML = `<div class="muted">Ingen oppgaver er helt uten dekning (ennå).</div>`;
    return;
  }

  wrap.innerHTML = `
    <div><b>${ignored.length}</b> oppgaver uten dekning:</div>
    <ul>
      ${ignored.map(t => `<li>${escapeHtml(t.title)}</li>`).join("")}
    </ul>
  `;
}

function renderSubmissions(plays, logs) {
  const logsByPlay = new Map((logs || []).map(l => [l.playthrough_id, l]));
  const wrap = document.getElementById("submissions");

  if (!plays.length) {
    wrap.innerHTML = `<div class="muted">Ingen innsendinger ennå.</div>`;
    return;
  }

  let html = `<table>
    <thead><tr><th>Navn</th><th>Tidspunkt</th><th></th></tr></thead><tbody>`;

  plays.forEach(p => {
    const when = p.submitted_at ? new Date(p.submitted_at).toLocaleString("nb-NO") : "";
    html += `<tr>
      <td><b>${escapeHtml(p.user_name)}</b></td>
      <td class="muted">${escapeHtml(when)}</td>
      <td><button data-id="${p.id}">Vis</button></td>
    </tr>`;
  });

  html += `</tbody></table>`;
  wrap.innerHTML = html;

  wrap.querySelectorAll("button[data-id]").forEach(btn => {
    btn.onclick = () => {
      const id = btn.getAttribute("data-id");
      const log = logsByPlay.get(id);
      const out = log?.raw ? JSON.stringify(log.raw, null, 2) : "(ingen logg)";
      document.getElementById("logView").textContent = out;
    };
  });
}

function exportAggregatedCsv() {
  if (!cache) return;

  const { tasks, timeByTask, moneyByTask } = cache;

  const rows = [];
  rows.push(["oppgave", "tid_total_pct", "handlingsrom_total_nok"].map(csv).join(","));

  tasks.forEach(t => {
    rows.push([
      t.title,
      timeByTask.get(t.id) || 0,
      moneyByTask.get(t.id) || 0
    ].map(csv).join(","));
  });

  const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `dashboard_aggregert_${new Date().toISOString().slice(0,10)}.csv`;
  a.click();
  URL.revokeObjectURL(url);
}

function csv(v) {
  return `"${String(v ?? "").replaceAll('"', '""')}"`;
}

function escapeHtml(s) {
  return String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;");
}
